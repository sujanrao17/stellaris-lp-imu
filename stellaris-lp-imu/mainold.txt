//*****************************************************************************
//
// hello.c - Simple hello world example.
//
// Copyright (c) 2012 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
//
// Texas Instruments (TI) is supplying this software for use solely and
// exclusively on TI's microcontroller products. The software is owned by
// TI and/or its suppliers, and is protected under applicable copyright
// laws. You may not combine this software with "viral" open-source
// software in order to form a larger program.
//
// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
// DAMAGES, FOR ANY REASON WHATSOEVER.
//
// This is part of revision 9453 of the EK-LM4F120XL Firmware Package.
//
//*****************************************************************************
#include <stdio.h>
#include "common.h"
#include "utils/uartstdio.h"
#include "adxl345.h"
#include "l3g4200d.h"
#include "hmc5883l.h"
#include "bmp085.h"
#include "i2c.h"
#include "stdio_console.h"

//*****************************************************************************
//
//! \addtogroup example_list
//! <h1>Hello World (hello)</h1>
//!
//! A very simple ``hello world'' example.  It simply displays ``Hello World!''
//! on the UART and is a starting point for more complicated applications.
//!
//! UART0, connected to the Stellaris Virtual Serial Port and running at
//! 115,200, 8-N-1, is used to display messages from this application.
//
//*****************************************************************************

//*****************************************************************************
//
// The error routine that is called if the driver library encounters an error.
//
//*****************************************************************************
#ifdef DEBUG
void
__error__(char *pcFilename, unsigned long ulLine)
{
}
#endif


int gXBuf[MAX_CALIB_SAMPLES];
int gYBuf[MAX_CALIB_SAMPLES];
int gZBuf[MAX_CALIB_SAMPLES];


int gAXRawAvg, gAYRawAvg, gAZRawAvg;
int gGXRawAvg, gGYRawAvg, gGZRawAvg;
int gMXRawAvg, gMYRawAvg, gMZRawAvg;
float gAXC, gAYC, gAZC;
float gGXC, gGYC, gGZC;
float gMXC, gMYC, gMZC;

#define MAX_AVG_SAMPLES 8
#define NUM_AVG_SAMPLES 4

int gAXBuf[MAX_AVG_SAMPLES];
int gAYBuf[MAX_AVG_SAMPLES];
int gAZBuf[MAX_AVG_SAMPLES];
int gMXBuf[MAX_AVG_SAMPLES];
int gMYBuf[MAX_AVG_SAMPLES];
int gMZBuf[MAX_AVG_SAMPLES];
int gGXBuf[MAX_AVG_SAMPLES];
int gGYBuf[MAX_AVG_SAMPLES];
int gGZBuf[MAX_AVG_SAMPLES];

float gQuaternion[4];
float gYPR[3];
float gYPRref[3];

int gnVersionNum = 86;

void ui_HandleCorruptUserParams(void);
void ui_ReadUserParams(void);
void ui_SetDefaultUserParams(void);
void ui_HMC5883LCalibrate(void);
void ui_ADXL345Calibrate(void);
void ui_L3GCalibrate(void);
void util_SerialPrintYPR(float ypr[]);
void util_GetXYLogical(volatile int* pX, volatile int* pY);
void util_FillAveragingBuffers(void);

volatile int xcounter = 0;
volatile int ycounter = 0;


int main(void) {
	volatile unsigned long ulLoop;

	//
	// Enable lazy stacking for interrupt handlers.  This allows floating-point
	// instructions to be used within interrupt handlers, but at the expense of
	// extra stack usage.
	//
	ROM_FPULazyStackingEnable();

	//
	// Set the clocking to run directly from the crystal.
	//
	ROM_SysCtlClockSet(
			SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ
					| SYSCTL_OSC_MAIN);

	ms = ROM_SysCtlClockGet() / 3000; // multiplier for SysCtlGet() store in global variables
	us = ms / 1000;
	//
	// Enable the GPIO port that is used for the on-board LED.
	//
	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

	//
	// Enable the GPIO pins for the LED (PF2 & PF3).
	//
	ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2);

	//
	// Initialize the UART1 for console.
	//
	InitConsole();

	i2c_Config();

	UARTprintf("\n\nGY-80 Initialising.\n");
	UARTprintf("Checking Sensors on i2c bus.\n\n");

	UARTprintf("L34200D (3-Axis gyroscope) : ");
	if (i2c_RcvByte(I2C_ID_L3G4200D, L3G_WHO_AM_I) == 0xD3) {
		UARTprintf("ok\n");
	} else {
		UARTprintf("missing\n");
	}

	UARTprintf("ADXL345 (3-Axis Accelerometer) : ");
	if (i2c_RcvByte(I2C_ID_ADXL345, ADXL345_DEVID) == 0xE5) {
		UARTprintf("ok\n");
	} else {
		UARTprintf("missing\n");
	}

	UARTprintf("HMC5883L (3-Axis Digital Compass) : ");
	if (i2c_RcvByte(I2C_ID_HMC5883L, HMC5883L_DEVID) == 0x3C) {
		UARTprintf("ok\n");
	} else {
		UARTprintf("missing\n");
	}

	UARTprintf("BMP085 (Barometric Pressure Sensor) : ");

	if (i2c_RcvByte(I2C_ID_BMP085, BMP085_DEVID) == 0x55) {
		UARTprintf("ok\n");
	} else {
		UARTprintf("missing\n");
	}

	ROM_SysCtlDelay(1000 * ms);

	UARTprintf("%c[?25l", ASCII_ESC);

	UARTprintf("%c[2J", ASCII_ESC);
	UARTprintf("%c[H", ASCII_ESC);
	UARTprintf("\nBMP085 Barometer Readings ");
	//   UARTprintf( "%c[3;0H", ASCII_ESC );
	UARTprintf("\n| Temperature |  Altitude   |   Pressure  |             |");

	UARTprintf("%c[6;0H", ASCII_ESC);
	UARTprintf("HMC5883L Compass Readings");
	//   UARTprintf( "%c[7;0H", ASCII_ESC );
	UARTprintf("\n|   X-Raw     |    Y-Raw    |   Z-Raw     |   Heading   |");

	UARTprintf("%c[10;0H", ASCII_ESC);
	UARTprintf("ADXL345 Accelerometer Readings");
	//   UARTprintf( "%c[13;0H", ASCII_ESC );
	UARTprintf("\n|   X-Axis    |    Y-Axis   |   Z-Axis    |             |");

	UARTprintf("%c[14;0H", ASCII_ESC);
	UARTprintf("L3G4200D Gryoscope Readings");
//    UARTprintf( "%c[18;0H", ASCII_ESC );
	UARTprintf("\n|   X-Axis    |    Y-Axis   |   Z-Axis    |             |");

	UARTprintf("%c[18;0H", ASCII_ESC);
	UARTprintf("IMU motion fusion");
//    UARTprintf( "%c[18;0H", ASCII_ESC );
	UARTprintf("\n|             |             |             | Compensated |");
	UARTprintf("\n|    Roll     |    Pitch    |     Yaw     |   Heading   |");


    adxl345_Config();
    hmc5883l_Config();
    l3g_Config();

	float IMU_temp, IMU_Atl, IMU_Heading, IMU_Compensted_heading;
	long IMU_Pressure = 0;

	float IMU_roll, IMU_pitch;

	char stringfloat1[20];
	char stringfloat2[20];
	char stringfloat3[20];
	char stringfloat4[20];

	while (1) {

		UARTprintf("%c[4;0H", ASCII_ESC);
		IMU_temp = BMP085readTemperature();
		sprintf(stringfloat1, "%03.2f", IMU_temp);

		IMU_Atl = BMP085readAltitude(101325);
		sprintf(stringfloat2, "%.2f", IMU_Atl);
		IMU_Pressure = BMP085readPressure();
		UARTprintf("|   %s*C   |   %sm    |  %08dpa |             |",
				stringfloat1, stringfloat2, IMU_Pressure);

		fflush(stdout);

		UARTprintf("%c[8;0H", ASCII_ESC);
		HMC5883LMagScaled HMC5883L_scaled = HMC5883LReadScaledAxis();
		HMC5883LMagRaw HMC5883L_raw = HMC5883LReadRawAxis();
		IMU_Heading = HMC5883LReadHeading();
		sprintf(stringfloat1, "%6.2f", IMU_Heading);
		UARTprintf("|   %05d     |    %05d    |   %05d     |   %s*   |",
				HMC5883L_raw.XAxis, HMC5883L_raw.YAxis, HMC5883L_raw.ZAxis,
				stringfloat1);

		fflush(stdout);

		UARTprintf("%c[12;0H", ASCII_ESC);
		ADXL345AccScaled ADXL345_scaled = ADXL345ReadScaledAxis();

		sprintf(stringfloat1, "%+09.5f", ADXL345_scaled.XAxis);
		sprintf(stringfloat2, "%+09.5f", ADXL345_scaled.YAxis);
		sprintf(stringfloat3, "%+09.5f", ADXL345_scaled.ZAxis);
		UARTprintf("| %sG  |  %sG | %sG  |             |", stringfloat1,
				stringfloat2, stringfloat3);

		fflush(stdout);

		UARTprintf("%c[16;0H", ASCII_ESC);

		L3G4200DGyroScaled L3G4200D_scaled = L3G4200DReadScaledAxis();

		sprintf(stringfloat1, "%+09.5f", L3G4200D_scaled.XAxis);
		sprintf(stringfloat2, "%+09.5f", L3G4200D_scaled.YAxis);
		sprintf(stringfloat3, "%+09.5f", L3G4200D_scaled.ZAxis);
		UARTprintf("| %s*  |  %s* | %s*  |             |", stringfloat1,
				stringfloat2, stringfloat3);


		IMU_pitch = 0;
		IMU_roll = 0;
		UARTprintf("%c[21;0H", ASCII_ESC);

		IMU_Compensted_heading = HMC5883ReadCompensatedHeading(
				ADXL345_scaled.XAxis, ADXL345_scaled.YAxis,
				ADXL345_scaled.ZAxis);

		sprintf(stringfloat1, "%+09.5f", IMU_roll);
		sprintf(stringfloat2, "%+09.5f", IMU_pitch);
		sprintf(stringfloat3, "%+09.5f", L3G4200D_scaled.ZAxis);

		if (IMU_Compensted_heading <= 360) {
			sprintf(stringfloat4, "%6.2f", IMU_Compensted_heading);
		} else {
			sprintf(stringfloat4, "ERROR");
		}

		UARTprintf("| %s*  |  %s* | %s*  |   %s*     |", stringfloat1,
				stringfloat2, stringfloat3, stringfloat4);

		fflush(stdout);

		DELAY_MS(1000);
	}

}
